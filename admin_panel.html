<!DOCTYPE html><html lang="zh-CN"><head><meta name="x-poe-datastore-behavior" content="local_only"><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: http://13.238.254.66:18000 http://127.0.0.1:9000 ws://13.238.254.66:18000 ws://127.0.0.1:9000 https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; connect-src 'self' http://13.238.254.66:18000 http://127.0.0.1:9000 ws://13.238.254.66:18000 ws://127.0.0.1:9000 https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; media-src 'self' blob: http://13.238.254.66:18000 http://127.0.0.1:9000; img-src 'self' data: blob: http://13.238.254.66:18000 http://127.0.0.1:9000 https:; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self' blob:;">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>æç®€æ¶æ„ - è§†é¢‘å¹³å°å¸ƒå±€éª¨æ¶</title>
  <!-- æ’­æ”¾æ‰€éœ€ï¼šMD5ï¼ˆç™»å½•ï¼‰ã€HLSã€HTTP-FLV -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.19.0/js/md5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@1.5.17/dist/hls.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flv.js@1.6.2/dist/flv.min.js"></script>
  <!-- å®˜æ–¹æ’­æ”¾å™¨ SDK ä¾èµ–ä¸æœ¬åœ°é•œåƒï¼ˆç”¨äºå¤ç°å®˜æ–¹ demo çš„æ’­æ”¾é“¾è·¯ï¼‰ -->
  <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.2.0/crypto-js.min.js"></script>
  <script src="vendor/EasyPlayer-pro.js"></script>
  <!-- å¼€æº EasyPlayer.jsï¼ˆä½ å·²æ‹‰åˆ°æœ¬åœ°ç›®å½•ï¼‰ -->
  <script src="EasyPlayer.js/js/EasyPlayer-pro.js"></script>
  <style>
    /* æç®€ï¼šåªåšå¸ƒå±€ï¼Œä¸åšä»»ä½•â€œé£æ ¼åŒ–â€ */
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; }
    body { font-family: sans-serif; }

    .app { height: 100%; display: flex; flex-direction: column; }

    /* é¡¶éƒ¨å¯¼èˆªï¼ˆæˆªå›¾ä¸€è‡´ï¼šå·¦å“ç‰Œ + ä¸­é—´èœå• + å³ä¾§æœç´¢/ç”¨æˆ·ï¼‰ */
    .topbar {
      height: 56px;
      display: flex;
      align-items: stretch;
      border-bottom: 1px solid #000;
    }
    .top-left {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 0 12px;
      min-width: 240px;
      border-right: 1px solid #000;
      white-space: nowrap;
    }
    .top-left a {
      color: inherit;
      text-decoration: none;
      cursor: pointer;
    }
    .top-left a:hover { text-decoration: underline; }
    .top-center {
      display: flex;
      align-items: stretch;
      gap: 0;
      flex: 1;
    }
    /* é¡¶éƒ¨èœå•åçš„â€œç©ºç™½åŒºâ€æ‰¿è½½æœç´¢æ¡†å¹¶å±…ä¸­ */
    .top-center-search {
      flex: 1 1 auto;
      min-width: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 12px;
    }
    .top-center-search input {
      width: min(520px, 100%);
    }
    .nav-item {
      display: flex;
      align-items: center;
      padding: 0 18px;
      border-right: 1px solid #000;
      cursor: pointer;
      user-select: none;
      position: relative;
    }
    .nav-item[aria-current="page"] { font-weight: 700; }

    .dropdown {
      display: none;
      position: absolute;
      top: 56px;
      left: 0;
      border: 1px solid #000;
      background: #fff;
      min-width: 160px;
      z-index: 10;
    }
    .dropdown a {
      display: block;
      padding: 10px 12px;
      border-bottom: 1px solid #000;
    }
    .dropdown a:last-child { border-bottom: 0; }
    .nav-item.open .dropdown { display: block; }

    .top-right {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 0 12px;
      min-width: 160px;
      border-left: 1px solid #000;
      white-space: nowrap;
    }
    .top-right input { width: 100%; }

    /* ä¸»ä½“ï¼šå·¦ä¾§åˆ—è¡¨æ  + å³ä¾§å†…å®¹åŒºï¼ˆæˆªå›¾ä¸€è‡´ï¼‰ */
    .main {
      flex: 1;
      display: grid;
      grid-template-columns: 280px 1fr;
      min-height: 0;
    }

    /* å·¦ä¾§é¢æ¿ï¼šé¡¶éƒ¨ tab + æœç´¢ + æ ‘åˆ—è¡¨ */
    .sidebar {
      border-right: 1px solid #000;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    .sidebar-search {
      display: grid;
      grid-template-columns: 1fr 72px;
      gap: 6px;
      padding: 10px;
      border-bottom: 1px solid #000;
    }

    /* æ¥å…¥çœŸå®å¹³å°ï¼šç™»å½•/åŠ è½½é€šé“å·¥å…·æ¡ï¼ˆæç®€ï¼‰ */
    .sidebar-auth {
      border-bottom: 1px solid #000;
      padding: 10px;
      display: grid;
      gap: 8px;
    }
    .sidebar-auth .row {
      display: grid;
      grid-template-columns: 86px 1fr;
      gap: 6px;
      align-items: center;
    }
    .sidebar-auth input { width: 100%; }
    .sidebar-auth .btnline { display: flex; gap: 6px; flex-wrap: wrap; }
    .sidebar-auth .hint { color: #333; font-size: 12px; line-height: 1.35; }
    .sidebar-auth .hint b { font-weight: 700; }
    .sidebar-auth textarea {
      width: 100%;
      min-height: 96px;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      line-height: 1.35;
    }
    .sidebar-body {
      overflow: auto;
      padding: 10px;
    }
    .tree {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .tree ul { list-style: none; padding: 0; margin: 0; }
    .tree .tree-group-list { padding-left: 18px; }

    .tree-item { margin: 0; }
    .tree-row {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 6px;
      border-bottom: 1px solid #000;
      user-select: none;
      cursor: pointer;
    }
    .tree-row.selected {
      background: #2f63ff;
      color: #fff;
    }

    .tree-caret {
      width: 16px;
      height: 16px;
      border: 0;
      padding: 0;
      background: transparent;
      cursor: pointer;
      display: grid;
      place-items: center;
      flex: 0 0 auto;
    }
    .tree-caret::before { content: 'â–¶'; font-size: 11px; line-height: 1; }
    .tree-group[aria-expanded="true"] > .tree-row .tree-caret::before { content: 'â–¼'; }
    .tree-caret.placeholder { cursor: default; }
    .tree-caret.placeholder::before { content: ''; }

    .tree-main {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
      flex: 1 1 auto;
    }
    .tree-icon { width: 16px; text-align: center; flex: 0 0 auto; }
    .tree-label {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .tree-right {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 10px;
      flex: 0 0 auto;
    }
    .tree-count {
      color: #0a8a20;
      font-variant-numeric: tabular-nums;
    }
    .tree-row.selected .tree-count { color: rgba(255,255,255,0.95); }

    .tree-fav {
      border: 0;
      background: transparent;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      padding: 2px;
      color: #666;
    }
    .tree-fav[aria-pressed="true"] { color: #f4c430; }
    .tree-row.selected .tree-fav { color: rgba(255,255,255,0.9); }

    .tree-group[aria-expanded="false"] > .tree-group-list { display: none; }

    /* å³ä¾§å†…å®¹ï¼šåªä¿ç•™â€œä¸»å†…å®¹ + åº•éƒ¨â€ï¼ˆä¸å†ä¿ç•™é¡¶éƒ¨ç©ºç™½ blockï¼‰ */
    .content {
      display: grid;
      grid-template-rows: 1fr;
      min-height: 0;
    }

    /* ä¸»åŒºï¼šè§†é¢‘å±•ç¤ºåŒºåŸŸï¼ˆå¤šç”»é¢ç½‘æ ¼ï¼‰ */
    .content-main {
      min-height: 0;
      overflow: auto;
      padding: 16px;
      display: block;
    }
    .video-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(420px, 1fr));
      gap: 16px;
      align-items: start;
    }
    /* å•é€‰æ‘„åƒæœºï¼šå³ä¾§æ˜¾ç¤ºâ€œå•ç”»é¢æ¨¡å¼â€ï¼Œä¸å†ç”¨ç½‘æ ¼æ’‘æ»¡å®½åº¦ */
    .video-grid.is-single {
      display: block;
    }

    /* å•ç”»é¢ï¼šä¸Šæ–¹è§†é¢‘ + ä¸‹æ–¹â€œæ’­æ”¾æ§åˆ¶/æµä¿¡æ¯/åˆ†äº«/æ’­æ”¾è¯Šæ–­â€ç­‰å ä½ */
    .viewer {
      border: 1px solid #000;
      display: grid;
      grid-template-rows: auto auto;
      min-height: 0;
    }
    .viewer-video {
      border-bottom: 1px solid #000;
      background: #f7f7f7;
    }
    /* å…³é”®ï¼šé«˜åº¦å›ºå®š 66vhï¼›ç”»é¢ä¸æ¨ªå‘æ‹‰ä¼¸ï¼Œå®½åº¦ç”±æ¯”ä¾‹å†³å®š */
    .viewer-frame {
      height: 66vh;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      background: #f7f7f7;
    }
    /* â€œç°ä»£ CCTVâ€ç”»å¹…æ¡†ï¼šæ ‡å‡† 16:9ï¼Œé»‘åº• + ç»†è¾¹æ¡†ï¼Œå±…ä¸­æ˜¾ç¤º */
    .cctv-box {
      height: 100%;
      max-width: 100%;
      aspect-ratio: 16 / 9;
      border: 1px solid #000;
      background: #000;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .cctv-video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
      z-index: 1;
    }
    .cctv-osd { z-index: 3; }
    .cctv-diag {
      position: absolute;
      left: 10px;
      bottom: 10px;
      z-index: 3;
      display: flex;
      gap: 6px;
      align-items: center;
      flex-wrap: wrap;
      max-width: calc(100% - 20px);
      pointer-events: auto;
    }
    .cctv-diag .pill {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      line-height: 1.2;
      color: rgba(255,255,255,0.95);
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.18);
      padding: 6px 8px;
      border-radius: 10px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .cctv-diag button {
      border: 1px solid rgba(255,255,255,0.55);
      background: rgba(0,0,0,0.25);
      color: rgba(255,255,255,0.95);
      padding: 6px 10px;
      border-radius: 10px;
      cursor: pointer;
    }
    .cctv-diag button:active { transform: translateY(1px); }
    /* çº¯å‰ç«¯â€œè§†é¢‘æ¨¡æ‹Ÿâ€å ä½ï¼ˆä¸ä½¿ç”¨ <img>ï¼Œé¿å…ç ´å›¾ï¼‰ */
    .video-placeholder {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      user-select: none;
      letter-spacing: 1px;
    }
    .video-placeholder.dark {
      color: rgba(255, 255, 255, 0.85);
      background:
        radial-gradient(circle at 20% 30%, rgba(255,255,255,0.10), transparent 40%),
        radial-gradient(circle at 70% 60%, rgba(255,255,255,0.07), transparent 45%),
        repeating-linear-gradient(0deg, rgba(255,255,255,0.06) 0 1px, rgba(0,0,0,0) 1px 3px),
        linear-gradient(135deg, rgba(255,255,255,0.05), rgba(0,0,0,0));
    }
    .video-placeholder.light {
      color: rgba(0, 0, 0, 0.75);
      background:
        repeating-linear-gradient(0deg, rgba(0,0,0,0.06) 0 1px, rgba(255,255,255,0) 1px 4px),
        linear-gradient(135deg, rgba(0,0,0,0.04), rgba(0,0,0,0));
    }
    .cctv-osd {
      position: absolute;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      line-height: 1.2;
      color: rgba(255,255,255,0.95);
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.18);
      padding: 6px 8px;
      border-radius: 10px;
      backdrop-filter: blur(6px);
      max-width: calc(100% - 20px);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      pointer-events: none;
    }
    .cctv-osd.tl { top: 10px; left: 10px; }
    .cctv-osd.br { bottom: 10px; right: 10px; }
    .viewer-tabs {
      display: flex;
      gap: 18px;
      padding: 10px 12px;
      border-bottom: 1px solid #000;
      white-space: nowrap;
      overflow: auto;
    }
    .viewer-tab {
      border: 0;
      padding: 0;
      background: transparent;
      cursor: pointer;
      font: inherit;
      text-decoration: none;
      color: inherit;
    }
    .viewer-tab.active {
      font-weight: 700;
      text-decoration: underline;
    }
    .viewer-panel {
      padding: 12px;
      display: grid;
      gap: 12px;
    }
    .block {
      border: 1px solid #000;
      padding: 12px;
      min-width: 0;
    }
    .block-title {
      font-weight: 700;
      margin-bottom: 10px;
    }
    .row {
      display: grid;
      grid-template-columns: 120px 1fr;
      gap: 10px;
      align-items: center;
      min-width: 0;
    }
    .row .label {
      white-space: nowrap;
    }
    .row .field {
      min-width: 0;
    }
    .chipsline {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    .chipbtn {
      border: 1px solid #000;
      background: transparent;
      padding: 6px 10px;
      cursor: pointer;
      white-space: nowrap;
      font: inherit;
    }
    .chipbtn.active {
      background: #2f63ff;
      color: #fff;
    }
    .field input[type="text"] {
      width: 100%;
    }
    .preset-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    .preset-list {
      border-top: 1px solid #000;
    }
    .preset-item {
      display: grid;
      grid-template-columns: 1fr 140px 60px 60px;
      gap: 10px;
      padding: 10px 0;
      border-bottom: 1px solid #000;
      align-items: center;
      min-width: 0;
    }
    .preset-item .muted { color: #333; }
    .video-tile {
      border: 1px solid #000;
      display: grid;
      grid-template-rows: 1fr auto;
      min-height: 0;
    }
    .video-thumb {
      border-bottom: 1px solid #000;
      background: #f7f7f7;
      aspect-ratio: 16 / 9;
      overflow: hidden;
    }
    .video-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    .video-meta {
      padding: 8px;
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: center;
    }
    .status {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }
    .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #0a8a20;
      display: inline-block;
    }
    .video-empty {
      border: 1px dashed #000;
      padding: 18px;
      color: #333;
    }

    /* åº•éƒ¨ç‰ˆæƒï¼ˆæˆªå›¾åº•éƒ¨ï¼‰ */
    .footer {
      border-top: 1px solid #000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 12px;
    }

    /* ç®€å•å“åº”ï¼šå°å±æ—¶å †å  */
    @media (max-width: 900px) {
      .main { grid-template-columns: 1fr; }
      .top-right { min-width: 220px; }
      .content-main { grid-template-columns: 1fr; }
    }
  </style>
</head>

<body>
  <div class="app">
    <!-- é¡¶éƒ¨å¯¼èˆª -->
    <header class="topbar" role="banner">
      <div class="top-left">
        <strong>Apex CCTV</strong>
        <span>|</span>
        <a href="homepage.html">é¦–é¡µ</a>
      </div>

      <nav class="top-center" aria-label="ä¸»å¯¼èˆª">
        <div class="nav-item" aria-current="page" data-nav="video">
          è§†é¢‘
        </div>

        <div class="nav-item" data-nav="device">
          è®¾å¤‡
          <div class="dropdown" role="menu" aria-label="è®¾å¤‡èœå•">
            <a href="device_management.html" role="menuitem">è®¾å¤‡ç®¡ç†</a>
            <a href="#" role="menuitem">åˆ†ç»„ç®¡ç†</a>
          </div>
        </div>

        <div class="nav-item" data-nav="user">
          ç”¨æˆ·
          <div class="dropdown" role="menu" aria-label="ç”¨æˆ·èœå•">
            <a href="user_management.html" role="menuitem">ç”¨æˆ·ç®¡ç†</a>
            <a href="#" role="menuitem">è§’è‰²ç®¡ç†</a>
          </div>
        </div>

        <div class="nav-item" data-nav="gallery">
          å›¾åº“
          <div class="dropdown" role="menu" aria-label="å›¾åº“èœå•">
            <a href="#" role="menuitem">ç½‘å…³å‘Šè­¦</a>
            <a href="#" role="menuitem">åè®®å‘Šè­¦</a>
            <a href="#" role="menuitem">1400å‘Šè­¦</a>
          </div>
        </div>

        <div class="nav-item" data-nav="ai">
          AI åˆ†æ
        </div>

        <div class="nav-item" data-nav="config">
          é…ç½®
          <div class="dropdown" role="menu" aria-label="é…ç½®èœå•">
            <a href="#" role="menuitem">åŸºç¡€é…ç½®</a>
            <a href="#" role="menuitem">å½•åƒé…ç½®</a>
            <a href="#" role="menuitem">å‘Šè­¦é…ç½®</a>
            <a href="#" role="menuitem">è®¾å¤‡æ¥å…¥</a>
            <a href="#" role="menuitem">è¿ç»´ç®¡ç†</a>
          </div>
        </div>
        <div class="top-center-search" aria-label="é¡¶éƒ¨æœç´¢">
          <input id="topSearchInput" placeholder="è¯·è¾“å…¥æœç´¢å†…å®¹">
        </div>
      </nav>

      <div class="top-right">
        <span>ç®¡ç†å‘˜</span>
      </div>
    </header>

    <!-- ä¸»ä½“ -->
    <div class="main">
      <!-- å·¦ä¾§åˆ—è¡¨æ  -->
      <aside class="sidebar" aria-label="å·¦ä¾§æ ">
        <div class="sidebar-search">
          <input id="treeSearchInput" placeholder="æœç´¢">
          <button type="button" id="treeSearchBtn">æœç´¢</button>
        </div>

        <div class="sidebar-auth" aria-label="çœŸå®è§†é¢‘æºæ¥å…¥">
          <div class="row">
            <div class="label">Base URL</div>
            <input id="apiBaseInput" value="http://13.238.254.66:18000" spellcheck="false">
          </div>
          <div class="row">
            <div class="label">ç”¨æˆ·å</div>
            <input id="apiUserInput" placeholder="ä¾‹å¦‚ï¼šeasycvr" autocomplete="username">
          </div>
          <div class="row">
            <div class="label">å¯†ç </div>
            <input id="apiPassInput" placeholder="ç™»å½•å¯†ç ï¼ˆå°†æŒ‰ md5 å°å†™æäº¤ï¼‰" type="password" autocomplete="current-password">
          </div>
          <div class="row">
            <div class="label">è®¾å¤‡ID</div>
            <input id="apiDeviceInput" placeholder="å¿…å¡«ï¼šä¾‹å¦‚ 8/22/24/26/27ï¼ˆæ¥è‡ªè®¾å¤‡ç®¡ç†é¡µâ€œç¼–å·â€ï¼‰" spellcheck="false">
          </div>
          <div class="btnline">
            <button type="button" id="btnLogin">ç™»å½•è·å–Token</button>
            <button type="button" id="btnLoadChannels">åŠ è½½é€šé“åˆ—è¡¨</button>
            <button type="button" id="btnLogout">é€€å‡º</button>
            <button type="button" id="btnTestPlay">æµ‹è¯•å½“å‰æ’­æ”¾URL</button>
            <button type="button" id="btnClearDiag">æ¸…ç©ºè¯Šæ–­</button>
            <button type="button" id="btnCopyDiag">å¤åˆ¶è¯Šæ–­</button>
          </div>
          <div class="hint" id="apiStatusHint">
            çŠ¶æ€ï¼šæœªç™»å½•ã€‚æç¤ºï¼šå¦‚æœç½‘é¡µè¯·æ±‚æŠ¥ CORSï¼Œè¯·æŠŠæœ¬é¡µé¢æ”¾åˆ° `13.238.254.66:18000` åŒåŸŸä¸‹è®¿é—®ï¼Œæˆ–è®©å‚å®¶å¼€å¯è·¨åŸŸã€‚
          </div>
          <textarea id="diagBox" readonly placeholder="æ’­æ”¾è¯Šæ–­è¾“å‡ºï¼ˆä¼šè®°å½•ï¼šé¡µé¢æ¥æºã€å½“å‰æ’­æ”¾URLã€m3u8/åˆ†ç‰‡/FLVæ¢æµ‹ã€videoäº‹ä»¶ã€hls.js/flv.jsé”™è¯¯ï¼‰"></textarea>
        </div>

        <div class="sidebar-body">
          <ul class="tree" id="deviceTree" role="tree" aria-label="è®¾å¤‡æ ‘"></ul>
        </div>
      </aside>

      <!-- å³ä¾§å†…å®¹åŒº -->
      <section class="content" aria-label="å†…å®¹åŒº">
        <!-- ä¸»å†…å®¹ï¼šè§†é¢‘å±•ç¤ºåŒºåŸŸï¼ˆç”±å·¦ä¾§é€‰æ‹©é©±åŠ¨ï¼‰ -->
        <div class="content-main">
          <div id="videoGrid" class="video-grid" aria-label="è§†é¢‘å±•ç¤ºåŒºåŸŸ"></div>
        </div>

      </section>
    </div>
  </div>

  <script>
    // æç®€äº¤äº’ï¼šé¡¶éƒ¨â€œä¸‹æ‹‰èœå•â€ç‚¹å‡»å¼€åˆï¼ˆç”¨äºè¿˜åŸæˆªå›¾ç»“æ„ï¼‰
    const navItems = document.querySelectorAll('.nav-item');
    function closeAll() { navItems.forEach(i => i.classList.remove('open')); }
    navItems.forEach(item => {
      item.addEventListener('click', (e) => {
        const hasDropdown = item.querySelector('.dropdown');
        if (!hasDropdown) { closeAll(); return; }
        const isOpen = item.classList.contains('open');
        closeAll();
        if (!isOpen) item.classList.add('open');
        e.stopPropagation();
      });
    });
    document.addEventListener('click', closeAll);
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeAll(); });

    // å·¦ä¾§è®¾å¤‡æ ‘ï¼šå±•å¼€/æŠ˜å ã€é€‰ä¸­ã€æ”¶è—ã€æœç´¢è¿‡æ»¤
    const tree = document.getElementById('deviceTree');
    const treeSearchInput = document.getElementById('treeSearchInput');
    const treeSearchBtn = document.getElementById('treeSearchBtn');
    const videoGrid = document.getElementById('videoGrid');
    const MAX_VIDEO_TILES = 6; // æ–‡ä»¶å¤¹é‡Œæ‘„åƒæœºå¾ˆå¤šæ—¶ï¼Œå³ä¾§æœ€å¤šå±•ç¤ºå¤šå°‘è·¯ï¼ˆæ¯æ¬¡ç‚¹å‡»ä¼šéšæœºæŠ½å–/æ‰“ä¹±ï¼‰

    // ===== çœŸå®å¹³å°æ¥å…¥ï¼ˆEasyCVR é£æ ¼ï¼‰=====
    const apiBaseInput = document.getElementById('apiBaseInput');
    const apiUserInput = document.getElementById('apiUserInput');
    const apiPassInput = document.getElementById('apiPassInput');
    const apiDeviceInput = document.getElementById('apiDeviceInput');
    const btnLogin = document.getElementById('btnLogin');
    const btnLoadChannels = document.getElementById('btnLoadChannels');
    const btnLogout = document.getElementById('btnLogout');
    const btnTestPlay = document.getElementById('btnTestPlay');
    const btnClearDiag = document.getElementById('btnClearDiag');
    const btnCopyDiag = document.getElementById('btnCopyDiag');
    const apiStatusHint = document.getElementById('apiStatusHint');
    const diagBox = document.getElementById('diagBox');

    const STORE_KEY = 'apexCctv.easycvr';
    const state = {
      baseUrl: 'http://13.238.254.66:18000',
      upstreamUrl: 'http://13.238.254.66:18000', // å¹³å°çœŸå®åœ°å€ï¼ˆç”¨äº streamInfo çš„ url å‚æ•°ï¼‰
      token: '',
      username: '',
      deviceId: '',
      hls: null,
      flv: null,
      easyPlayer: null, // å®˜æ–¹ SDK æ’­æ”¾å™¨å®ä¾‹ï¼ˆè‹¥å¯ç”¨ï¼‰
      lastAddrs: null,
      lastCam: null,
      proto: 'HLS', // é»˜è®¤ï¼šæµè§ˆå™¨æœ€ç¨³ï¼ˆåªè‡ªåŠ¨ç”¨ HLS/FLVï¼‰
      _autoTried: {}, // { "device__channel": { HLS: true, FLV: true } }
    };

    function setStatus(msg) {
      if (apiStatusHint) apiStatusHint.textContent = msg;
    }

    const diag = { lines: [] };
    function nowTs() {
      const d = new Date();
      return d.toISOString().replace('T', ' ').slice(0, 19);
    }
    function logDiag(line) {
      const s = `[${nowTs()}] ${String(line)}`;
      diag.lines.push(s);
      if (diag.lines.length > 400) diag.lines.splice(0, diag.lines.length - 400);
      if (diagBox instanceof HTMLTextAreaElement) {
        diagBox.value = diag.lines.join('\n');
        diagBox.scrollTop = diagBox.scrollHeight;
      }
      try { console.log(s); } catch {}
    }

    window.addEventListener('error', (e) => {
      logDiag(`window.error: ${e?.message || e}`);
    });
    window.addEventListener('unhandledrejection', (e) => {
      logDiag(`unhandledrejection: ${e?.reason?.message || e?.reason || e}`);
    });

    function attachVideoDebug(videoEl) {
      if (!(videoEl instanceof HTMLVideoElement)) return;
      const evs = ['loadstart','loadedmetadata','loadeddata','canplay','canplaythrough','play','playing','pause','waiting','stalled','seeking','seeked','ended','error','timeupdate'];
      evs.forEach((ev) => {
        videoEl.addEventListener(ev, () => {
          const err = videoEl.error ? ` err=${videoEl.error.code}` : '';
          const t = Number.isFinite(videoEl.currentTime) ? videoEl.currentTime.toFixed(2) : 'NaN';
          const d = Number.isFinite(videoEl.duration) ? videoEl.duration.toFixed(2) : 'NaN';
          const wh = `${videoEl.videoWidth || 0}x${videoEl.videoHeight || 0}`;
          let q = '';
          try {
            const pq = videoEl.getVideoPlaybackQuality?.();
            if (pq) q = ` frames=${pq.totalVideoFrames || 0} dropped=${pq.droppedVideoFrames || 0}`;
          } catch {}
          logDiag(`video.${ev}: t=${t} dur=${d} wh=${wh} ready=${videoEl.readyState} net=${videoEl.networkState}${q}${err}`);
        }, { passive: true });
      });
    }

    async function fetchTextSafe(url, options) {
      const res = await fetch(url, options);
      const text = await res.text();
      return { res, text };
    }

    function extractCodecsFromM3u8(text) {
      const m = String(text || '').match(/CODECS=\"([^\"]+)\"/i);
      return m ? m[1] : '';
    }

    function resolveRelativeUrl(baseUrl, maybeRelative) {
      try {
        return new URL(maybeRelative, baseUrl).toString();
      } catch {
        return '';
      }
    }

    async function testCurrentPlayUrl() {
      const input = document.getElementById('playUrlInput');
      const url = (input instanceof HTMLInputElement) ? input.value.trim() : '';
      if (!url) {
        logDiag('æµ‹è¯•å¤±è´¥ï¼šæœªæ‰¾åˆ°å½“å‰æ’­æ”¾URLï¼ˆè¯·å…ˆç‚¹å‡»ä¸€ä¸ªé€šé“ï¼‰ã€‚');
        return;
      }
      logDiag(`==== æµ‹è¯•å¼€å§‹ ====`);
      logDiag(`page.origin=${location.origin} page.href=${location.href}`);
      logDiag(`baseUrl=${state.baseUrl}`);
      logDiag(`proto=${state.proto} url=${url}`);

      const isM3u8 = /\.m3u8(\?|$)/i.test(url);
      const isFlv = /\.flv(\?|$)/i.test(url);

      try {
        if (isM3u8) {
          logDiag('æ¢æµ‹ï¼šGET playlist.m3u8');
          const { res, text } = await fetchTextSafe(url, { method: 'GET' });
          logDiag(`playlist: status=${res.status} ct=${res.headers.get('content-type') || ''}`);
          logDiag(`playlist.head:\n${text.slice(0, 400)}`);
          const codecs = extractCodecsFromM3u8(text);
          if (codecs) logDiag(`playlist.CODECS=${codecs}`);

          // å¦‚æœæ˜¯ master playlistï¼ˆå« EXT-X-STREAM-INFï¼‰ï¼Œå†æŠ“ç¬¬ä¸€æ¡ variant playlistï¼Œçœ‹ç¼–ç ä¿¡æ¯
          if (/#EXT-X-STREAM-INF/i.test(text)) {
            const lines0 = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
            const idx = lines0.findIndex(l => /^#EXT-X-STREAM-INF/i.test(l));
            const variantRel = (idx >= 0 && lines0[idx + 1] && !lines0[idx + 1].startsWith('#')) ? lines0[idx + 1] : '';
            if (variantRel) {
              const variantUrl = resolveRelativeUrl(url, variantRel);
              logDiag(`æ¢æµ‹ï¼šGET variant playlist ${variantUrl}`);
              const { res: r2, text: t2 } = await fetchTextSafe(variantUrl, { method: 'GET' });
              logDiag(`variant: status=${r2.status} ct=${r2.headers.get('content-type') || ''}`);
              logDiag(`variant.head:\n${t2.slice(0, 300)}`);
              const c2 = extractCodecsFromM3u8(t2);
              if (c2) logDiag(`variant.CODECS=${c2}`);
            }
          }
          const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
          const seg = lines.find(l => !l.startsWith('#'));
          if (!seg) {
            logDiag('playlist é‡Œæœªæ‰¾åˆ°åˆ†ç‰‡è¡Œï¼ˆå¯èƒ½è¿”å›äº†é”™è¯¯é¡µ/ç©ºå†…å®¹ï¼‰');
            return;
          }
          const segUrl = resolveRelativeUrl(url, seg);
          logDiag(`æ¢æµ‹ï¼šGET é¦–ä¸ªåˆ†ç‰‡ ${segUrl}`);
          const segRes = await fetch(segUrl, { method: 'GET' });
          logDiag(`segment: status=${segRes.status} ct=${segRes.headers.get('content-type') || ''}`);
          return;
        }

        if (isFlv) {
          logDiag('æ¢æµ‹ï¼šGET FLV Range bytes=0-2047');
          const res = await fetch(url, { method: 'GET', headers: { Range: 'bytes=0-2047' } });
          logDiag(`flv: status=${res.status} ct=${res.headers.get('content-type') || ''} cr=${res.headers.get('content-range') || ''}`);
          return;
        }

        logDiag('æ¢æµ‹ï¼šURL é m3u8/flvï¼Œå°è¯• GET');
        const res = await fetch(url, { method: 'GET' });
        logDiag(`generic: status=${res.status} ct=${res.headers.get('content-type') || ''}`);
      } catch (e) {
        logDiag(`æ¢æµ‹å¤±è´¥ï¼š${e?.message || e}`);
        logDiag('å¦‚æœæ˜¯ â€œFailed to fetchâ€ï¼Œæœ€å¸¸è§åŸå› æ˜¯ï¼šè·¨åŸŸ(CORS) æˆ– mixed-contentã€‚å»ºè®®æŠŠæœ¬é¡µé¢æ”¾åˆ° http://13.238.254.66:18000 åŒåŸŸä¸‹è®¿é—®ï¼Œæˆ–ç”¨åå‘ä»£ç†ã€‚');
      } finally {
        logDiag(`==== æµ‹è¯•ç»“æŸ ====`);
      }
    }

    function saveState() {
      try {
        const payload = {
          baseUrl: state.baseUrl,
          upstreamUrl: state.upstreamUrl,
          token: state.token,
          username: state.username,
          deviceId: state.deviceId,
          proto: state.proto,
        };
        localStorage.setItem(STORE_KEY, JSON.stringify(payload));
      } catch {}
    }

    function loadState() {
      try {
        const raw = localStorage.getItem(STORE_KEY);
        if (!raw) return;
        const v = JSON.parse(raw);
        if (typeof v?.baseUrl === 'string') state.baseUrl = v.baseUrl;
        if (typeof v?.upstreamUrl === 'string') state.upstreamUrl = v.upstreamUrl;
        if (typeof v?.token === 'string') state.token = v.token;
        if (typeof v?.username === 'string') state.username = v.username;
        if (typeof v?.deviceId === 'string') state.deviceId = v.deviceId;
        if (typeof v?.proto === 'string') state.proto = v.proto;
      } catch {}
    }

    function normalizeBaseUrl(u) {
      const x = (u || '').trim().replace(/\/+$/, '');
      return x || 'http://13.238.254.66:18000';
    }

    function normalizeUpstreamUrl(u) {
      const x = (u || '').trim().replace(/\/+$/, '');
      return x || 'http://13.238.254.66:18000';
    }

    function joinUrl(base, path) {
      const p = (path || '').trim();
      if (!p) return '';
      if (/^https?:\/\//i.test(p) || /^wss?:\/\//i.test(p)) return p;
      const b = normalizeBaseUrl(base);
      return p.startsWith('/') ? (b + p) : (b + '/' + p);
    }

    function joinUpstream(path) {
      const p = (path || '').trim();
      if (!p) return '';
      if (/^https?:\/\//i.test(p) || /^wss?:\/\//i.test(p)) return p;
      const b = normalizeUpstreamUrl(state.upstreamUrl);
      return p.startsWith('/') ? (b + p) : (b + '/' + p);
    }

    function getOfficialSdk() {
      // UMD å…¨å±€åæ˜¯ "EasyPlayer-pro"ï¼ˆå¸¦çŸ­æ¨ªçº¿ï¼‰ï¼Œåªèƒ½ç”¨ bracket è®¿é—®
      // æ³¨æ„ï¼šä½ æœ¬åœ°çš„ EasyPlayer.js ä¹Ÿä¼šå¯¼å‡º window.EasyPlayerProï¼Œæˆ‘ä»¬ä¼˜å…ˆæ‹¿å®ƒï¼ˆå®ƒæ”¯æŒ H265/WASM/WebCodecï¼‰ã€‚
      const sdk = window.EasyPlayerPro || window["EasyPlayer-pro"] || window.EasyPlayer || null;
      return sdk;
    }

    async function playWithEasyPlayerJs(playUrl) {
      const SDK = window.EasyPlayerPro;
      logDiag(`EasyPlayer.js: detect typeof=${typeof SDK}`);
      if (typeof SDK !== 'function') throw new Error('æœªæ£€æµ‹åˆ° EasyPlayer.jsï¼ˆEasyPlayerPro æœªåŠ è½½ï¼‰');

      const mount = document.getElementById('sdkMount');
      if (!(mount instanceof HTMLElement)) throw new Error('æœªæ‰¾åˆ° SDK æŒ‚è½½å®¹å™¨');
      mount.innerHTML = '';

      // éšè—æˆ‘ä»¬è‡ªå·±çš„ <video>
      const v = document.getElementById('liveVideoEl');
      if (v instanceof HTMLVideoElement) v.style.display = 'none';

      // æŒ‰ READMEï¼šnew EasyPlayerPro(container, config)ï¼›ç„¶å player.play(url)
      const config = {
        isLive: true,
        hasAudio: true,
        isMute: true,
        stretch: true,
        debug: true,
        // è§£ç æ¨¡å¼ï¼šä¼˜å…ˆå°è¯• WebCodec/GPUï¼Œå…¶æ¬¡ WASMï¼ˆé«˜åˆ†è¾¨ç‡å»ºè®® SIMDï¼‰
        gpuDecoder: true,
        WASM: true,
        WASMSIMD: true,
        // ä½ è¿™è·¯æ˜¯ flv/h265ï¼Œå»ºè®®å¼ºåˆ¶ flv è§£ç è·¯å¾„
        isFlv: true,
        // wasm æ–‡ä»¶ä¸ js åŒç›®å½•ï¼›éƒ¨åˆ†ç‰ˆæœ¬ä¼šæŒ‰ç›¸å¯¹è·¯å¾„åŠ è½½
        decoderWASM: "EasyPlayer.js/js/EasyPlayer-pro.wasm",
      };

      const inst = new SDK(mount, config);
      state.easyPlayer = inst;
      logDiag(`EasyPlayer.js: instance keys=${Object.keys(inst || {}).slice(0, 30).join(',')}`);
      if (typeof inst.play !== 'function') throw new Error('EasyPlayerPro å®ä¾‹ç¼ºå°‘ play(url) æ–¹æ³•');
      await inst.play(playUrl);
      setStatus('çŠ¶æ€ï¼šå·²åˆ‡æ¢ä¸º EasyPlayer.js æ’­æ”¾');
      return inst;
    }

    async function playWithOfficialSdk(playUrl) {
      const sdk = getOfficialSdk();
      logDiag(`SDK: detect typeof=${typeof sdk}`);
      if (!sdk) throw new Error('æœªæ£€æµ‹åˆ°å®˜æ–¹ SDKï¼ˆEasyPlayer-pro.js æœªåŠ è½½æˆåŠŸï¼‰');

      const mount = document.getElementById('sdkMount');
      if (!(mount instanceof HTMLElement)) throw new Error('æœªæ‰¾åˆ° SDK æŒ‚è½½å®¹å™¨');
      // å…³é”®ï¼šå®˜æ–¹ SDK ä¸å…è®¸å¤ç”¨åŒä¸€ä¸ª containerï¼ˆä¼šæ‰“ data-EasyProv æ ‡è®°ï¼Œå¤ç”¨å°±æŠ› "err container"ï¼‰
      // æ‰€ä»¥æˆ‘ä»¬æ¯æ¬¡æ’­æ”¾éƒ½åˆ›å»ºä¸€ä¸ªå…¨æ–°çš„ inner containerï¼Œå¹¶ä¼ ç»™ SDK
      mount.innerHTML = '';
      const inner = document.createElement('div');
      inner.style.cssText = 'position:absolute;inset:0;width:100%;height:100%;';
      mount.appendChild(inner);

      // éšè—æˆ‘ä»¬è‡ªå·±çš„ <video>ï¼Œé¿å…ä¸¤å¥—æ’­æ”¾å™¨å åŠ 
      const v = document.getElementById('liveVideoEl');
      if (v instanceof HTMLVideoElement) v.style.display = 'none';

      // SDK é»˜è®¤ä¼šå»æ‹‰ /EasyPlayerPro/ ä¸‹çš„ decoder/wasm ç­‰èµ„æºï¼š
      // - ä½ åœ¨ç”¨æœ¬åœ°ä»£ç†æ—¶ï¼ˆ127.0.0.1:9000ï¼‰ï¼Œæˆ‘ä»¬å·²è®© proxy_server.py ä»£ç† /EasyPlayerPro/ åˆ°ä¸Šæ¸¸
      // - æ‰€ä»¥ decoderPath ç”¨ç›¸å¯¹è·¯å¾„å³å¯ï¼ˆèµ°å½“å‰ç«™ç‚¹åŒæºï¼‰
      const baseOpt = {
        isLive: true,
        lang: "zh",
        debug: true,
        decoderPath: "/EasyPlayerPro/",
        mainThreadFetchUseWorker: true,
      };

      // å¤šç§å¯èƒ½çš„å¯¼å‡ºå½¢æ€ï¼Œé€ä¸€å°è¯•
      let inst = null;
      const opts = [{ ...baseOpt, container: inner }];

      const factories = [];
      if (typeof sdk === 'function') factories.push((o) => new sdk(o));
      if (sdk && typeof sdk.default === 'function') factories.push((o) => new sdk.default(o));
      if (sdk && typeof sdk.create === 'function') factories.push((o) => sdk.create(o));
      if (sdk && typeof sdk.createPlayer === 'function') factories.push((o) => sdk.createPlayer(o));

      let lastErr = null;
      outer: for (const make of factories) {
        for (const o of opts) {
          try {
            inst = make(o);
            lastErr = null;
            break outer;
          } catch (e) {
            lastErr = e;
          }
        }
      }
      if (!inst) throw new Error(`SDK åˆå§‹åŒ–å¤±è´¥ï¼š${lastErr?.message || lastErr || 'unknown'}`);

      state.easyPlayer = inst;
      logDiag(`SDK: instance keys=${Object.keys(inst || {}).slice(0, 30).join(',')}`);
      logDiag(`SDK: methods play=${typeof inst.play} load=${typeof inst.load} start=${typeof inst.start} setUrl=${typeof inst.setUrl} setSource=${typeof inst.setSource}`);

      // å…³é”®ï¼šè¯¥ SDK æ„é€ æ—¶ä¼šæŠŠ _opt.url å¼ºåˆ¶æ¸…ç©ºï¼Œæ‰€ä»¥å¿…é¡»ä¼ å‚è°ƒç”¨ play(url)
      if (typeof inst.play !== 'function') throw new Error('SDK å®ä¾‹ç¼ºå°‘ play() æ–¹æ³•');
      await inst.play(playUrl, { isLive: true });

      setStatus('çŠ¶æ€ï¼šå·²åˆ‡æ¢ä¸ºå®˜æ–¹ SDK æ’­æ”¾ï¼ˆè‹¥ä»æ— ç”»é¢ï¼Œè¯·çœ‹è¯Šæ–­è¾“å‡ºï¼‰');
      return inst;
    }

    function toUpstreamUrl(playUrl) {
      // å¦‚æœå½“å‰æ’­æ”¾ URL èµ°çš„æ˜¯æœ¬åœ°ä»£ç†(127.0.0.1)ï¼Œåˆ™æ›¿æ¢ä¸ºçœŸå®å¹³å°åœ°å€ï¼Œä¾¿äº /api/v1/streamInfo è¯†åˆ«
      try {
        const u = new URL(playUrl);
        if (u.hostname === '127.0.0.1' || u.hostname === 'localhost') {
          const b = new URL(normalizeUpstreamUrl(state.upstreamUrl));
          u.protocol = b.protocol;
          u.hostname = b.hostname;
          u.port = b.port;
          return u.toString();
        }
      } catch {}
      return playUrl;
    }

    async function apiGet(path, params, token) {
      const base = normalizeBaseUrl(state.baseUrl);
      const url = new URL(joinUrl(base, path));
      const qs = new URLSearchParams();
      Object.entries(params || {}).forEach(([k, v]) => {
        if (v === undefined || v === null) return;
        const s = String(v).trim();
        if (!s) return;
        qs.set(k, s);
      });
      url.search = qs.toString();

      const headers = {};
      if (token) headers['Token'] = token;
      const res = await fetch(url.toString(), { method: 'GET', headers });
      const text = await res.text();
      let json = null;
      try { json = JSON.parse(text); } catch { /* é JSON ä¹Ÿè¿”å› */ }
      if (!res.ok) {
        const msg = typeof json === 'object' ? JSON.stringify(json) : text;
        throw new Error(`HTTP ${res.status}: ${msg}`.slice(0, 500));
      }
      return json ?? text;
    }

    function unwrapEasyDarwin(json) {
      if (!json || typeof json !== 'object') return { ok: false, msg: 'å“åº”ä¸æ˜¯ JSON å¯¹è±¡', body: null, raw: json };
      // å¸¸è§ï¼š{ EasyDarwin: { Header:{ErrorNum,ErrorString}, Body:{...} } }
      const ed = json.EasyDarwin || json.easydarwin || json;
      const header = ed?.Header || ed?.header || null;
      const body = ed?.Body || ed?.body || ed;
      const code = header?.ErrorNum ?? header?.errorNum ?? header?.Code ?? header?.code ?? 200;
      const msg = header?.ErrorString ?? header?.errorString ?? header?.Message ?? header?.message ?? '';
      const ok = Number(code) === 200 || Number(code) === 0;
      return { ok, code, msg, body, raw: json };
    }

    async function doLogin() {
      const base = normalizeBaseUrl(apiBaseInput?.value || state.baseUrl);
      const username = (apiUserInput?.value || '').trim();
      const passPlain = apiPassInput?.value || '';
      if (!username || !passPlain) throw new Error('è¯·è¾“å…¥ç”¨æˆ·åå’Œå¯†ç ');
      if (typeof window.md5 !== 'function') throw new Error('md5 åº“æœªåŠ è½½ï¼ˆè¯·æ£€æŸ¥ç½‘ç»œ/CDN/CSPï¼‰');
      const passMd5 = String(window.md5(passPlain)).toLowerCase();

      state.baseUrl = base;
      state.username = username;
      saveState();

      setStatus('çŠ¶æ€ï¼šç™»å½•ä¸­...');
      const json = await apiGet('/api/v1/login', { username, password: passMd5 }, '');
      const r = unwrapEasyDarwin(json);
      if (!r.ok) throw new Error(`ç™»å½•å¤±è´¥ï¼š${r.msg || 'æœªçŸ¥é”™è¯¯'}`);
      const token = r.body?.Token || r.body?.token || '';
      if (!token) throw new Error('ç™»å½•æˆåŠŸä½†æœªè¿”å› Tokenï¼ˆè¯·æ£€æŸ¥è¿”å›å­—æ®µï¼‰');
      state.token = token;
      saveState();
      setStatus(`çŠ¶æ€ï¼šå·²ç™»å½•ï¼ˆ${username}ï¼‰ï¼ŒToken å·²ä¿å­˜ï¼ˆé»˜è®¤ 7 å¤©æœ‰æ•ˆæœŸï¼‰`);
    }

    function pickChannelLabel(ch) {
      return (
        ch?.Name ||
        ch?.ChannelName ||
        ch?.CustomName ||
        ch?.DeviceName ||
        ch?.ChannelID ||
        ch?.ChannelId ||
        'é€šé“'
      );
    }

    function renderChannelTree(channels) {
      if (!tree) return;
      const groups = new Map(); // deviceId => channels[]
      (channels || []).forEach(ch => {
        const dev = String(ch?.ParentDeviceID ?? ch?.parentDeviceID ?? ch?.DeviceID ?? ch?.deviceID ?? '').trim();
        const cid = String(ch?.ChannelID ?? ch?.channelID ?? ch?.ChannelId ?? ch?.channelId ?? '').trim();
        if (!dev || !cid) return;
        if (!groups.has(dev)) groups.set(dev, []);
        groups.get(dev).push({ raw: ch, deviceId: dev, channelId: cid, name: pickChannelLabel(ch) });
      });

      if (groups.size === 0) {
        tree.innerHTML = `<li class="tree-item tree-leaf" role="treeitem"><div class="tree-row" data-tree-row><span class="tree-caret placeholder" aria-hidden="true"></span><span class="tree-main"><span class="tree-icon" aria-hidden="true">ğŸ“</span><span class="tree-label">æœªè·å–åˆ°é€šé“ï¼ˆè¯·æ£€æŸ¥ device å‚æ•°/Token/CORSï¼‰</span></span></div></li>`;
        return;
      }

      const sortedDevices = Array.from(groups.keys()).sort();
      tree.innerHTML = sortedDevices.map((devId) => {
        const arr = groups.get(devId) || [];
        const count = arr.length;
        const leafHtml = arr.map((c) => {
          const safeName = String(c.name).replace(/</g, '&lt;').replace(/>/g, '&gt;');
          return `
            <li class="tree-item tree-leaf" role="treeitem" data-device-id="${c.deviceId}" data-channel-id="${c.channelId}">
              <div class="tree-row" data-tree-row>
                <span class="tree-caret placeholder" aria-hidden="true"></span>
                <span class="tree-main">
                  <span class="tree-icon" aria-hidden="true">ğŸ“·</span>
                  <span class="tree-label">${safeName}</span>
                </span>
                <span class="tree-right">
                  <button class="tree-fav" type="button" aria-label="æ”¶è—" aria-pressed="false" title="æ”¶è—" data-tree-fav>â˜†</button>
                </span>
              </div>
            </li>
          `;
        }).join('');

        return `
          <li class="tree-item tree-group" role="treeitem" aria-expanded="true" data-device-id="${devId}">
            <div class="tree-row" data-tree-row>
              <button class="tree-caret" type="button" aria-label="å±•å¼€/æŠ˜å " data-tree-toggle></button>
              <span class="tree-main">
                <span class="tree-icon" aria-hidden="true">ğŸ“</span>
                <span class="tree-label">${devId}</span>
              </span>
              <span class="tree-right">
                <span class="tree-count">(${count})</span>
              </span>
            </div>
            <ul class="tree-group-list" role="group">${leafHtml}</ul>
          </li>
        `;
      }).join('');
    }

    async function loadChannels() {
      if (!state.token) {
        setStatus('çŠ¶æ€ï¼šæœªç™»å½•ï¼Œæ— æ³•åŠ è½½é€šé“ã€‚è¯·å…ˆâ€œç™»å½•è·å–Tokenâ€ã€‚');
        return;
      }
      state.baseUrl = normalizeBaseUrl(apiBaseInput?.value || state.baseUrl);
      state.deviceId = (apiDeviceInput?.value || state.deviceId || '').trim();
      saveState();

      setStatus('çŠ¶æ€ï¼šåŠ è½½é€šé“åˆ—è¡¨ä¸­...');
      if (!state.deviceId) {
        // æŒ‰ä½ æœ€æ–°æ±‡æ€»ï¼šchannelsconfig çš„ device ä¸ºå¿…å¡«
        setStatus('çŠ¶æ€ï¼šè¯·å…ˆå¡«å†™è®¾å¤‡IDï¼ˆä¾‹å¦‚ä½ è®¾å¤‡ç®¡ç†é¡µçœ‹åˆ°çš„ 8/22/24/26/27ï¼‰ï¼Œå†ç‚¹â€œåŠ è½½é€šé“åˆ—è¡¨â€ã€‚');
        return;
      }
      const params = { start: 0, limit: 500, device: state.deviceId };
      const json = await apiGet('/api/v1/channelsconfig', params, state.token);
      const r = unwrapEasyDarwin(json);
      if (!r.ok) throw new Error(`è·å–é€šé“å¤±è´¥ï¼š${r.msg || 'æœªçŸ¥é”™è¯¯'}`);
      const chans = r.body?.Channels || r.body?.channels || r.body?.Data || r.body?.data || [];
      renderChannelTree(Array.isArray(chans) ? chans : []);
      setStatus(`çŠ¶æ€ï¼šé€šé“åŠ è½½å®Œæˆã€‚å…± ${Array.isArray(chans) ? chans.length : 0} æ¡ï¼ˆå·²æŒ‰ ParentDeviceID åˆ†ç»„æ˜¾ç¤ºï¼‰ã€‚`);
    }

    async function getStreamAddrs(deviceId, channelId) {
      if (!state.token) throw new Error('æœªç™»å½•ï¼ˆç¼º Tokenï¼‰');
      const json = await apiGet('/api/v1/devices/channelstreamalladdr', { device: deviceId, channel: channelId }, state.token);
      const r = unwrapEasyDarwin(json);
      if (!r.ok) throw new Error(`è·å–æµåœ°å€å¤±è´¥ï¼š${r.msg || 'æœªçŸ¥é”™è¯¯'}`);
      const body = r.body || {};
      return body;
    }

    function destroyPlayers() {
      try { state.hls?.destroy?.(); } catch {}
      try { state.flv?.destroy?.(); } catch {}
      try {
        // å®˜æ–¹ SDK å®ä¾‹å¸¸è§é”€æ¯æ–¹æ³•
        state.easyPlayer?.destroy?.();
        state.easyPlayer?.close?.();
        state.easyPlayer?.stop?.();
      } catch {}
      state.hls = null;
      state.flv = null;
      state.easyPlayer = null;
    }

    function camKey(deviceId, channelId) {
      return `${String(deviceId || '')}__${String(channelId || '')}`;
    }

    function resetTried(deviceId, channelId) {
      state._autoTried[camKey(deviceId, channelId)] = {};
    }

    function markTried(deviceId, channelId, proto) {
      const key = camKey(deviceId, channelId);
      if (!state._autoTried[key]) state._autoTried[key] = {};
      state._autoTried[key][proto] = true;
    }

    function hasTried(deviceId, channelId, proto) {
      const key = camKey(deviceId, channelId);
      return !!state._autoTried[key]?.[proto];
    }

    function scheduleVideoHealthCheck(deviceId, channelId, currentProto) {
      // 3.5 ç§’åæ£€æŸ¥æ˜¯å¦è§£ç å‡ºè§†é¢‘å¸§ï¼›è‹¥ wh ä»ä¸º 0ï¼Œåˆ™è‡ªåŠ¨åˆ‡æ¢ HLS/FLV å¦ä¸€ç§åè®®é‡è¯•ä¸€æ¬¡
      window.setTimeout(async () => {
        const v = document.getElementById('liveVideoEl');
        if (!(v instanceof HTMLVideoElement)) return;
        const w = v.videoWidth || 0;
        const h = v.videoHeight || 0;
        logDiag(`healthcheck: proto=${currentProto} wh=${w}x${h}`);
        if (w > 0 && h > 0) return;

        logDiag('æç¤ºï¼šwh=0x0 è¡¨ç¤ºæµè§ˆå™¨æœªè§£ç å‡ºè§†é¢‘å¸§ã€‚é«˜æ¦‚ç‡åŸå› ï¼š');
        logDiag('- æ‘„åƒæœº/å¹³å°è¾“å‡ºä¸º H.265(HEVC) æˆ–å…¶ä»–æµè§ˆå™¨ä¸æ”¯æŒç¼–ç ï¼ˆæœ€å¸¸è§ï¼‰');
        logDiag('- æˆ–è¯¥æµåªæœ‰éŸ³é¢‘/é»‘å¸§ï¼ˆæ— è§†é¢‘è½¨ï¼‰');
        logDiag('å¤„ç†å»ºè®®ï¼šåœ¨å¹³å°æŠŠè¯¥é€šé“ä¸»/å­ç æµæ”¹ä¸º H.264 + AACï¼Œå†è¯•ã€‚');

        // é¢å¤–ï¼šè°ƒç”¨ /api/v1/streamInfo ç›´æ¥ç¡®è®¤ç¼–ç /åˆ†è¾¨ç‡
        try {
          const rel = state.lastAddrs?.HLS || state.lastAddrs?.hls || state.lastAddrs?.FLV || state.lastAddrs?.flv || '';
          const full = joinUpstream(rel);
          if (full) {
            const info = await apiGet('/api/v1/streamInfo', { url: full, channel: channelId }, state.token);
            // è¯¥æ¥å£çœ‹èµ·æ¥æ˜¯â€œç›´æ¥ JSONâ€è€Œé EasyDarwin åŒ…è£¹
            logDiag(`streamInfo: ${JSON.stringify(info)}`);
            const vc = String(info?.video_codec || '').toUpperCase();
            if (vc.includes('265') || vc.includes('HEVC') || vc.includes('H265')) {
              logDiag('ç»“è®ºï¼švideo_codec=H265/HEVCï¼Œæµè§ˆå™¨å¤§æ¦‚ç‡æ— æ³•è§£ç ï¼Œæ‰€ä»¥ wh=0x0ã€‚éœ€è¦åœ¨å¹³å°/æ‘„åƒæœºä¾§è½¬ä¸º H264ã€‚');
            }
          }
        } catch (e) {
          logDiag(`streamInfo: è°ƒç”¨å¤±è´¥ - ${e?.message || e}`);
        }

        const other = (currentProto === 'HLS') ? 'FLV' : 'HLS';
        if (hasTried(deviceId, channelId, other)) return;
        const nextUrl = getProtoUrl(state.lastAddrs, other);
        if (!nextUrl) return;

        try {
          logDiag(`healthcheck: è‡ªåŠ¨åˆ‡æ¢åˆ° ${other} é‡è¯•...`);
          destroyPlayers();
          markTried(deviceId, channelId, other);
          setProto(other);
          const playUrlInput = document.getElementById('playUrlInput');
          if (playUrlInput instanceof HTMLInputElement) playUrlInput.value = nextUrl;
          await mountPlayer(nextUrl, other);
          setStatus(`çŠ¶æ€ï¼šè‡ªåŠ¨é‡è¯•æ’­æ”¾ï¼ˆ${other}ï¼‰`);
        } catch (e) {
          logDiag(`healthcheck: è‡ªåŠ¨åˆ‡æ¢å¤±è´¥ - ${e?.message || e}`);
        }
      }, 3500);
    }

    function setProto(next) {
      // ä»…æ”¯æŒè‡ªåŠ¨æ’­æ”¾ï¼šHLS / FLV
      const n = String(next || '').toUpperCase();
      state.proto = (n === 'HLS' || n === 'FLV') ? n : 'HLS';
      saveState();
    }

    function getProtoUrl(addrs, proto) {
      if (!addrs || typeof addrs !== 'object') return '';
      const raw = addrs?.[proto] ?? addrs?.[String(proto).toUpperCase()] ?? addrs?.[String(proto).toLowerCase()];
      return joinUrl(state.baseUrl, raw || '');
    }

    async function playCam(deviceId, channelId, name) {
      destroyPlayers();
      state.lastCam = { deviceId, channelId, name };
      resetTried(deviceId, channelId);
      setStatus(`çŠ¶æ€ï¼šè·å–æµåœ°å€ä¸­... device=${deviceId} channel=${channelId}`);
      const addrs = await getStreamAddrs(deviceId, channelId);
      state.lastAddrs = addrs;

      // åªè‡ªåŠ¨é€‰æ‹©æµè§ˆå™¨å¯æ§æ–¹æ¡ˆï¼šHLS / HTTP-FLV
      const preferred = (String(state.proto || 'HLS').toUpperCase() === 'FLV') ? 'FLV' : 'HLS';
      let url = getProtoUrl(addrs, preferred);
      let proto = preferred;
      if (!url) {
        url = getProtoUrl(addrs, 'HLS') || getProtoUrl(addrs, 'FLV') || '';
        proto = url.includes('.m3u8') ? 'HLS' : 'FLV';
      }
      if (!url) throw new Error('æ¥å£è¿”å›é‡Œæœªæ‰¾åˆ°å¯ç”¨æ’­æ”¾åœ°å€ï¼ˆBody.HLS / Body.FLV ç­‰ä¸ºç©ºï¼‰');

      renderSingleViewer({ id: channelId, name: name || channelId, deviceId, channelId }, url, proto);
      markTried(deviceId, channelId, proto);

      // æ’­æ”¾å‰å…ˆæŸ¥ streamInfoï¼š
      // - H264ï¼šç»§ç»­èµ° hls.js/flv.js
      // - H265ï¼šä¸è¦é˜»æ­¢ç”¨æˆ·ä½¿ç”¨â€œå®˜æ–¹SDKæ’­â€ï¼ˆå®˜æ–¹ demo å°±æ˜¯è¿™æ ·æ’­çš„ï¼‰
      try {
        const upstreamPlayUrl = toUpstreamUrl(url);
        const info = await apiGet('/api/v1/streamInfo', { url: upstreamPlayUrl, channel: channelId }, state.token);
        logDiag(`streamInfo(pre): ${JSON.stringify(info)}`);
        const vc = String(info?.video_codec || '').toUpperCase();
        const size = `${info?.video_width || 0}x${info?.video_height || 0}`;
        if (vc) logDiag(`streamInfo(pre).video_codec=${vc} size=${size} fps=${info?.fps ?? ''} audio=${info?.audio_codec || ''}`);
        if (vc.includes('265') || vc.includes('HEVC') || vc.includes('H265')) {
          const overlay = document.getElementById('codecOverlay');
          if (overlay) {
            overlay.style.display = 'flex';
            const hasSdk = !!getOfficialSdk();
            overlay.textContent =
              hasSdk
                ? `è¯¥é€šé“ä¸º H265/HEVCï¼ˆ${size}ï¼‰ã€‚æœ¬é¡µé¢çš„é€šç”¨æ’­æ”¾å™¨ï¼ˆHLS/FLVï¼‰åœ¨ Chrome/Edge é€šå¸¸æ— æ³•è§£ç ï¼Œæ‰€ä»¥ä¼šé»‘å±ã€‚\n\nä½ å¯ä»¥ç›´æ¥ç‚¹å‡»å³ä¸‹è§’ã€Œç”¨å®˜æ–¹SDKæ’­ã€ç»§ç»­ï¼ˆå¤ç°å®˜æ–¹ demoï¼‰ï¼Œæˆ–åœ¨å¹³å°/æ‘„åƒæœºæŠŠç æµæ”¹ä¸º H264 åå†ç”¨é€šç”¨æ’­æ”¾å™¨æ’­æ”¾ã€‚`
                : `è¯¥é€šé“ä¸º H265/HEVCï¼ˆ${size}ï¼‰ã€‚æœ¬é¡µé¢çš„é€šç”¨æ’­æ”¾å™¨ï¼ˆHLS/FLVï¼‰åœ¨ Chrome/Edge é€šå¸¸æ— æ³•è§£ç ï¼Œæ‰€ä»¥ä¼šé»‘å±ã€‚\n\nå½“å‰æœªæ£€æµ‹åˆ°å®˜æ–¹SDKï¼Œè¯·æŠŠç æµæ”¹ä¸º H264ï¼ˆå»ºè®® 1080p æˆ–æ›´ä½ï¼‰ï¼Œå†åˆ·æ–°é‡è¯•ã€‚`;
          }
          setStatus('çŠ¶æ€ï¼šæ£€æµ‹åˆ° H265/HEVCã€‚è¯·ç‚¹ã€Œç”¨å®˜æ–¹SDKæ’­ã€ï¼Œæˆ–æ”¹ä¸º H264ã€‚');
          // ä¸å† returnï¼›è®©ç”¨æˆ·å¯æ‰‹åŠ¨ç‚¹â€œç”¨å®˜æ–¹SDKæ’­â€
          // ä½†è¿™é‡Œä¸ç»§ç»­èµ°é€šç”¨æ’­æ”¾å™¨ï¼Œé¿å…æ— æ„ä¹‰çš„é»‘å±ç­‰å¾…
          return;
        }
      } catch (e) {
        logDiag(`streamInfo(pre): å¤±è´¥ - ${e?.message || e}`);
      }

      await mountPlayer(url, proto);
      setStatus(`çŠ¶æ€ï¼šæ’­æ”¾ä¸­ï¼ˆ${proto}ï¼‰`);
      scheduleVideoHealthCheck(deviceId, channelId, proto);
    }

    function renderSingleViewer(cam, url, proto) {
      if (!videoGrid) return;
      videoGrid.classList.add('is-single');
      videoGrid.innerHTML = `
        <div class="viewer" data-cam-id="${cam.channelId}">
          <div class="viewer-video" aria-label="è§†é¢‘ç”»é¢åŒºåŸŸ">
            <div class="viewer-frame">
              <div class="cctv-box" aria-label="CCTV ç”»å¹…ï¼ˆ16:9ï¼‰">
                <video id="liveVideoEl" class="cctv-video" playsinline muted autoplay controls></video>
                <div id="sdkMount" style="position:absolute;inset:0;z-index:1;"></div>
                <div id="codecOverlay" class="video-placeholder dark" style="position:absolute; inset:0; z-index:2; display:none; padding:18px;">
                  <!-- è‡ªåŠ¨å†™å…¥æç¤º -->
                </div>
                <div class="cctv-osd tl">${new Date().toISOString().replace('T',' ').slice(0,19)}</div>
                <div class="cctv-osd br">${cam.name}</div>
                <div class="cctv-diag" aria-label="ç”»é¢è¯Šæ–­">
                  <span class="pill" id="pillWh">wh: -</span>
                  <span class="pill" id="pillProto">proto: ${proto}</span>
                  <button type="button" id="btnSnapFrame">æŠ“ä¸€å¸§</button>
                  <button type="button" id="btnQueryStreamInfo">æµä¿¡æ¯</button>
                  <button type="button" id="btnUseOfficialSdk">ç”¨SDKæ’­</button>
                  <button type="button" id="btnUseEasyPlayerJs">ç”¨EasyPlayer.jsæ’­</button>
                </div>
              </div>
            </div>
          </div>

          <div>
            <div class="viewer-tabs" role="tablist" aria-label="åŠŸèƒ½åŒº">
              <button class="viewer-tab active" type="button" role="tab" aria-selected="true">æ’­æ”¾æ§åˆ¶</button>
              <button class="viewer-tab" type="button" role="tab" aria-selected="false">æµä¿¡æ¯</button>
              <button class="viewer-tab" type="button" role="tab" aria-selected="false">åˆ†äº«</button>
              <button class="viewer-tab" type="button" role="tab" aria-selected="false">æ’­æ”¾è¯Šæ–­</button>
            </div>

            <div class="viewer-panel">
              <div class="block">
                <div class="block-title">ç æµåˆ‡æ¢</div>
                <div class="chipsline" aria-label="ç æµåè®®åˆ‡æ¢">
                  <button class="chipbtn ${proto === 'FLV' ? 'active' : ''}" type="button" data-proto="FLV">HTTP-FLV</button>
                  <button class="chipbtn ${proto === 'HLS' ? 'active' : ''}" type="button" data-proto="HLS">HLS</button>
                  <button class="chipbtn" type="button" data-proto="WEBRTC" disabled title="WebRTC é€šå¸¸éœ€è¦å‚å®¶ä¸“ç”¨å¯¹æ¥/SDK">WebRTC</button>
                  <button class="chipbtn" type="button" data-proto="WS_FLV" disabled title="WS-FLV éœ€è¦ä¸“ç”¨æ’­æ”¾å™¨/SDK">WS-FLV</button>
                  <button class="chipbtn" type="button" data-proto="FMP4" disabled title="FMP4/WS-FMP4 æœªåœ¨æœ¬é¡µé¢å®ç°">HTTP-FMP4</button>
                  <button class="chipbtn" type="button" data-proto="WS_FMP4" disabled title="FMP4/WS-FMP4 æœªåœ¨æœ¬é¡µé¢å®ç°">WS-FMP4</button>
                </div>
              </div>

              <div class="block">
                <div class="block-title">ç æµåœ°å€</div>
                <div class="row">
                  <div class="label">æ’­æ”¾åœ°å€</div>
                  <div class="field">
                    <input id="playUrlInput" type="text" value="${String(url).replace(/"/g,'&quot;')}">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      `;

      // video äº‹ä»¶è¯Šæ–­
      const liveV = document.getElementById('liveVideoEl');
      attachVideoDebug(liveV);
      const pillWh = document.getElementById('pillWh');
      const tick = () => {
        if (!(liveV instanceof HTMLVideoElement)) return;
        if (pillWh) pillWh.textContent = `wh: ${liveV.videoWidth || 0}x${liveV.videoHeight || 0}`;
        requestAnimationFrame(tick);
      };
      requestAnimationFrame(tick);

      const btnSnapFrame = document.getElementById('btnSnapFrame');
      btnSnapFrame?.addEventListener('click', () => {
        try {
          if (!(liveV instanceof HTMLVideoElement)) return;
          const w = liveV.videoWidth || 0;
          const h = liveV.videoHeight || 0;
          logDiag(`snap: video wh=${w}x${h}`);
          if (!w || !h) { logDiag('snap: videoWidth/videoHeight ä¸º 0ï¼ˆæµå¯èƒ½æ— è§†é¢‘è½¨æˆ–æ— æ³•è§£ç ï¼‰'); return; }
          const c = document.createElement('canvas');
          c.width = w;
          c.height = h;
          const ctx = c.getContext('2d');
          if (!ctx) { logDiag('snap: canvas ctx ä¸ºç©º'); return; }
          ctx.drawImage(liveV, 0, 0, w, h);
          const dataUrl = c.toDataURL('image/png');
          // æ‰“å¼€æ–°çª—å£æ˜¾ç¤ºæŠ“å¸§ï¼ˆæœ€ç›´è§‚ï¼‰
          const win = window.open('', '_blank');
          if (win) win.document.write(`<title>æŠ“å¸§</title><img src="${dataUrl}" style="max-width:100%;height:auto;">`);
          logDiag('snap: å·²æ‰“å¼€æ–°çª—å£æ˜¾ç¤ºæŠ“å¸§');
        } catch (e) {
          logDiag(`snap: å¤±è´¥ - ${e?.message || e}`);
          logDiag('snap å¤±è´¥å¦‚æœæ˜¯ SecurityErrorï¼Œè¯´æ˜ä»æœ‰è·¨åŸŸæ±¡æŸ“ï¼ˆè¯·ç¡®è®¤é€šè¿‡æœ¬åœ°ä»£ç†åŒæºåŠ è½½ï¼‰ã€‚');
        }
      });

      // ç»‘å®šåè®®åˆ‡æ¢
      const chips = videoGrid.querySelectorAll('[data-proto]');
      chips.forEach(btn => {
        btn.addEventListener('click', async () => {
          const p = btn.getAttribute('data-proto') || 'HLS';
          setProto(p);
          // é HLS/FLV çš„æŒ‰é’®ç›®å‰ç¦ç”¨ï¼›è¿™é‡Œä»åšä¿æŠ¤
          const nextUrl = getProtoUrl(state.lastAddrs, state.proto);
          const playUrlInput = document.getElementById('playUrlInput');
          if (playUrlInput instanceof HTMLInputElement) playUrlInput.value = nextUrl || '';
          if (!nextUrl) {
            setStatus(`çŠ¶æ€ï¼šè¯¥é€šé“æœªè¿”å› ${state.proto} åœ°å€ï¼ˆæ¥å£å­—æ®µä¸ºç©ºï¼‰`);
            return;
          }
          try {
            destroyPlayers();
            await mountPlayer(nextUrl, state.proto);
            setStatus(`çŠ¶æ€ï¼šåˆ‡æ¢æ’­æ”¾æˆåŠŸï¼ˆ${state.proto}ï¼‰`);
          } catch (e) {
            setStatus(`çŠ¶æ€ï¼šåˆ‡æ¢æ’­æ”¾å¤±è´¥ï¼ˆ${state.proto}ï¼‰- ${(e && e.message) ? e.message : String(e)}`);
          }
        });
      });

      const btnQueryStreamInfo = document.getElementById('btnQueryStreamInfo');
      btnQueryStreamInfo?.addEventListener('click', async () => {
        try {
          const input = document.getElementById('playUrlInput');
          const playUrl = (input instanceof HTMLInputElement) ? input.value.trim() : '';
          if (!playUrl) { logDiag('streamInfo: å½“å‰æ— æ’­æ”¾URL'); return; }
          // streamInfo çš„ url å‚æ•°å»ºè®®ä¼ â€œå¹³å°å¯è®¿é—®çš„çœŸå®åœ°å€â€
          let upstreamPlayUrl = playUrl;
          try {
            const u = new URL(playUrl);
            const base = normalizeUpstreamUrl(state.upstreamUrl);
            const b = new URL(base);
            // å¦‚æœå½“å‰æ’­æ”¾èµ°çš„æ˜¯æœ¬åœ°ä»£ç†ï¼Œåˆ™æ›¿æ¢ä¸ºçœŸå®ä¸Šæ¸¸ host/port
            if (u.hostname === '127.0.0.1' || u.hostname === 'localhost') {
              u.protocol = b.protocol;
              u.hostname = b.hostname;
              u.port = b.port;
              upstreamPlayUrl = u.toString();
            }
          } catch {}
          logDiag(`streamInfo: query url=${upstreamPlayUrl} channel=${cam.channelId}`);
          const info = await apiGet('/api/v1/streamInfo', { url: upstreamPlayUrl, channel: cam.channelId }, state.token);
          logDiag(`streamInfo: ${JSON.stringify(info)}`);
          const vc = String(info?.video_codec || '').toUpperCase();
          if (vc) logDiag(`streamInfo.video_codec=${vc} size=${info?.video_width || 0}x${info?.video_height || 0} fps=${info?.fps ?? ''} audio=${info?.audio_codec || ''}`);
          if (vc.includes('265') || vc.includes('HEVC') || vc.includes('H265')) {
            logDiag('ç»“è®ºï¼švideo_codec=H265/HEVCï¼Œæµè§ˆå™¨å¤§æ¦‚ç‡æ— æ³•è§£ç ï¼Œéœ€è¦æ”¹ä¸º H264ã€‚');
          }
        } catch (e) {
          logDiag(`streamInfo: å¤±è´¥ - ${e?.message || e}`);
        }
      });

      const btnUseOfficialSdk = document.getElementById('btnUseOfficialSdk');
      btnUseOfficialSdk?.addEventListener('click', async () => {
        try {
          const input = document.getElementById('playUrlInput');
          const playUrl = (input instanceof HTMLInputElement) ? input.value.trim() : '';
          if (!playUrl) { logDiag('SDK: å½“å‰æ— æ’­æ”¾URL'); return; }
          await playWithOfficialSdk(playUrl);
        } catch (e) {
          logDiag(`SDK: æ’­æ”¾å¤±è´¥ - ${e?.message || e}`);
          setStatus(`çŠ¶æ€ï¼šSDK æ’­æ”¾å¤±è´¥ - ${e?.message || e}`);
        }
      });

      const btnUseEasyPlayerJs = document.getElementById('btnUseEasyPlayerJs');
      btnUseEasyPlayerJs?.addEventListener('click', async () => {
        try {
          const input = document.getElementById('playUrlInput');
          const playUrl = (input instanceof HTMLInputElement) ? input.value.trim() : '';
          if (!playUrl) { logDiag('EasyPlayer.js: å½“å‰æ— æ’­æ”¾URL'); return; }
          destroyPlayers();
          await playWithEasyPlayerJs(playUrl);
        } catch (e) {
          logDiag(`EasyPlayer.js: æ’­æ”¾å¤±è´¥ - ${e?.message || e}`);
          setStatus(`çŠ¶æ€ï¼šEasyPlayer.js æ’­æ”¾å¤±è´¥ - ${e?.message || e}`);
        }
      });
    }

    async function mountPlayer(url, proto) {
      const v = document.getElementById('liveVideoEl');
      if (!(v instanceof HTMLVideoElement)) throw new Error('æœªæ‰¾åˆ° video å…ƒç´ ');
      v.pause();
      v.removeAttribute('src');
      v.load();

      // è¯´æ˜ï¼šWS_FLV/WS_FMP4/WebRTC é€šå¸¸éœ€è¦å‚å®¶ SDK æˆ–ç‰¹æ®Šå®ç°ï¼Œè¿™é‡Œå…ˆåšæœ€ç¨³çš„ HLS/HTTP-FLV
      if (proto === 'HLS') {
        if (v.canPlayType('application/vnd.apple.mpegurl')) {
          v.src = url;
          await v.play().catch(() => {});
          return;
        }
        if (window.Hls && window.Hls.isSupported()) {
          const hls = new window.Hls({
            enableWorker: true,
            lowLatencyMode: true,
            // æŸäº›ç¯å¢ƒä¸‹é¦–å¸§æ›´ç¨³
            backBufferLength: 30,
          });
          state.hls = hls;
          hls.loadSource(url);
          hls.attachMedia(v);
          await new Promise((resolve, reject) => {
            let done = false;
            const timer = setTimeout(() => {
              if (!done) reject(new Error('HLS åŠ è½½è¶…æ—¶ï¼ˆè¯·æ£€æŸ¥ m3u8/åˆ†ç‰‡è¯·æ±‚æ˜¯å¦ 200ï¼Œæˆ–æ˜¯å¦è¢« CORS æ‹¦æˆªï¼‰'));
            }, 12000);

            function finishOk() {
              if (done) return;
              done = true;
              clearTimeout(timer);
              resolve();
            }

            function fail(msg) {
              if (done) return;
              done = true;
              clearTimeout(timer);
              reject(new Error(msg || 'HLS æ’­æ”¾å¤±è´¥'));
            }

            hls.on(window.Hls.Events.MANIFEST_PARSED, finishOk);
            hls.on(window.Hls.Events.ERROR, (_evt, data) => {
              // æ³¨æ„ï¼šhls.js ä¼šæœ‰å¤§é‡é fatal çš„ ERRORï¼›ä¸èƒ½è§é”™å°±å¤±è´¥
              if (!data) return;
              logDiag(`hls.error: fatal=${!!data.fatal} type=${data.type || ''} details=${data.details || ''}`);
              if (!data.fatal) return;

              const t = data.type || '';
              if (t === window.Hls.ErrorTypes.NETWORK_ERROR) {
                // ç½‘ç»œé”™è¯¯ï¼šå°è¯•é‡è½½
                try { hls.startLoad(); } catch {}
                return;
              }
              if (t === window.Hls.ErrorTypes.MEDIA_ERROR) {
                // è§£ç /åª’ä½“é”™è¯¯ï¼šå°è¯•æ¢å¤
                try { hls.recoverMediaError(); } catch {}
                return;
              }

              fail(data?.details || data?.type || 'HLS fatal é”™è¯¯');
            });
          });
          await v.play().catch(() => {});
          logDiag('HLSï¼šæ’­æ”¾å™¨å·²æŒ‚è½½å¹¶å°è¯•æ’­æ”¾ã€‚');
          return;
        }
        throw new Error('å½“å‰æµè§ˆå™¨ä¸æ”¯æŒ HLSï¼ˆä¸” hls.js ä¸å¯ç”¨ï¼‰');
      }

      if (proto === 'FLV') {
        if (!window.flvjs || !window.flvjs.isSupported()) throw new Error('å½“å‰æµè§ˆå™¨ä¸æ”¯æŒ flv.jsï¼ˆæˆ– MSE ä¸å¯ç”¨ï¼‰');
        // æ³¨æ„ï¼šåœ¨ä¸¥æ ¼ CSP ä¸‹ï¼Œflv.js é»˜è®¤ä¼šç”¨ blob: workerï¼›è¿™é‡Œå·²æ”¾å¼€ worker-src blob:
        // å¦‚ä»è¢«ä¼ä¸šç­–ç•¥æ‹¦æˆªï¼Œå¯æŠŠ enableWorker æ”¹ä¸º falseï¼ˆä½†æ€§èƒ½ä¼šä¸‹é™ï¼‰ã€‚
        const flv = window.flvjs.createPlayer({ type: 'flv', url, isLive: true }, { enableWorker: true, stashInitialSize: 128 });
        state.flv = flv;
        flv.attachMediaElement(v);
        try {
          flv.on(window.flvjs.Events.ERROR, (errType, errDetail) => {
            logDiag(`flvjs.error: type=${errType} detail=${errDetail}`);
          });
        } catch {}
        flv.load();
        await v.play().catch(() => {});
        logDiag('FLVï¼šæ’­æ”¾å™¨å·²æŒ‚è½½å¹¶å°è¯•æ’­æ”¾ã€‚');
        return;
      }

      // å…¶ä»–åè®®å…ˆé€€åŒ–ï¼šç›´æ¥æŠŠ url å¡ç»™ videoï¼ˆè‹¥æœåŠ¡å™¨è¿”å›çš„æ˜¯å¯ç›´æ¥æ’­æ”¾çš„åœ°å€ä¹Ÿèƒ½æ’­ï¼‰
      v.src = url;
      await v.play().catch(() => {});
    }

    function setSelectedRow(rowEl) {
      if (!rowEl) return;
      tree?.querySelectorAll('.tree-row.selected').forEach(r => r.classList.remove('selected'));
      rowEl.classList.add('selected');
    }

    function toggleFav(btn) {
      const pressed = btn.getAttribute('aria-pressed') === 'true';
      const next = !pressed;
      btn.setAttribute('aria-pressed', String(next));
      btn.textContent = next ? 'â˜…' : 'â˜†';
    }

    function toggleGroup(li) {
      if (!li || !li.classList.contains('tree-group')) return;
      const expanded = li.getAttribute('aria-expanded') === 'true';
      li.setAttribute('aria-expanded', expanded ? 'false' : 'true');
    }

    function shuffle(arr) {
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function getItemLabel(li) {
      const labelEl = li?.querySelector(':scope > .tree-row .tree-label');
      return (labelEl?.textContent || '').trim();
    }

    function getLeafItemsUnderGroup(groupLi) {
      return Array.from(groupLi.querySelectorAll(':scope > .tree-group-list > .tree-item.tree-leaf'));
    }

    async function renderVideosForLeaf(leafLi) {
      if (!videoGrid) return;
      const deviceId = leafLi.getAttribute('data-device-id') || '';
      const channelId = leafLi.getAttribute('data-channel-id') || '';
      const name = getItemLabel(leafLi) || channelId || 'é€šé“';
      if (deviceId && channelId) {
        try {
          await playCam(deviceId, channelId, name);
          return;
        } catch (e) {
          setStatus(`çŠ¶æ€ï¼šæ’­æ”¾å¤±è´¥ - ${(e && e.message) ? e.message : String(e)}`);
        }
      }
      // å…¼å®¹ï¼šå¦‚æœæ˜¯æ—§çš„é™æ€ demo èŠ‚ç‚¹ï¼Œå°±åªæ¸²æŸ“å ä½
      const id = leafLi.getAttribute('data-id') || channelId || 'cam';
      renderVideoTiles([{ id, name }]);
    }

    function renderVideosForGroup(groupLi) {
      if (!videoGrid) return;
      const leaves = getLeafItemsUnderGroup(groupLi);
      const cams = leaves.map(li => ({
        id: li.getAttribute('data-channel-id') || li.getAttribute('data-id') || 'cam',
        name: getItemLabel(li) || (li.getAttribute('data-channel-id') || li.getAttribute('data-id') || 'cam')
      }));
      if (cams.length === 0) {
        videoGrid.innerHTML = `<div class="video-empty">è¯¥æ–‡ä»¶å¤¹ä¸‹æš‚æ— æ‘„åƒæœºï¼ˆ0 è·¯ï¼‰</div>`;
        return;
      }
      // éšæœºè€ŒåŠ¨ï¼šæ¯æ¬¡ç‚¹å‡»éƒ½æ‰“ä¹±é¡ºåºï¼Œå¹¶åœ¨è¶…å‡ºä¸Šé™æ—¶éšæœºæŠ½å–ä¸€éƒ¨åˆ†
      const shuffled = shuffle(cams);
      const picked = shuffled.slice(0, Math.min(MAX_VIDEO_TILES, shuffled.length));
      renderVideoTiles(picked);
    }

    function renderVideoTiles(cams) {
      if (!videoGrid) return;
      const nowSeed = Date.now();
      const isSingle = Array.isArray(cams) && cams.length === 1;
      videoGrid.classList.toggle('is-single', isSingle);

      if (isSingle) {
        const cam = cams[0];
        videoGrid.innerHTML = `
          <div class="viewer" data-cam-id="${cam.id}">
            <div class="viewer-video" aria-label="è§†é¢‘ç”»é¢åŒºåŸŸ">
              <div class="viewer-frame">
                <div class="cctv-box" aria-label="CCTV ç”»å¹…ï¼ˆ16:9ï¼‰">
                  <div class="video-placeholder dark" aria-hidden="true">è¯·é€‰æ‹©å·¦ä¾§çœŸå®é€šé“ï¼ˆæˆ–å…ˆç™»å½•/åŠ è½½é€šé“ï¼‰</div>
                  <div class="cctv-osd tl">${new Date().toISOString().replace('T',' ').slice(0,19)}</div>
                  <div class="cctv-osd br">${cam.name}</div>
                </div>
              </div>
            </div>
          </div>
        `;
        return;
      }

      videoGrid.innerHTML = cams.map((cam, idx) => {
        return `
          <div class="video-tile" data-cam-id="${cam.id}">
            <div class="video-thumb">
              <div class="video-placeholder light" aria-hidden="true">è§†é¢‘æ¨¡æ‹Ÿ</div>
            </div>
            <div class="video-meta">
              <div>[${idx + 1}] ${cam.name}</div>
              <div class="status"><span class="dot"></span>åœ¨çº¿</div>
            </div>
          </div>
        `;
      }).join('');
    }

    function textIncludes(haystack, needle) {
      return haystack.toLowerCase().includes(needle.toLowerCase());
    }

    function filterTree(query) {
      const q = (query || '').trim();
      const hasQ = q.length > 0;

      function processItem(li) {
        const labelEl = li.querySelector(':scope > .tree-row .tree-label');
        const selfLabel = (labelEl?.textContent || '').trim();
        const selfMatch = !hasQ || textIncludes(selfLabel, q);

        if (li.classList.contains('tree-group')) {
          const children = li.querySelectorAll(':scope > .tree-group-list > .tree-item');
          let anyChildMatch = false;
          children.forEach(child => {
            if (processItem(child)) anyChildMatch = true;
          });

          const show = selfMatch || anyChildMatch;
          li.style.display = show ? '' : 'none';

          // æœç´¢æ—¶ï¼šå¦‚æœå­é¡¹å‘½ä¸­ï¼Œåˆ™è‡ªåŠ¨å±•å¼€çˆ¶èŠ‚ç‚¹ï¼Œæ–¹ä¾¿çœ‹åˆ°ç»“æœ
          if (hasQ && anyChildMatch) li.setAttribute('aria-expanded', 'true');

          return show;
        }

        // å¶å­èŠ‚ç‚¹
        li.style.display = selfMatch ? '' : 'none';
        return selfMatch;
      }

      tree?.querySelectorAll(':scope > .tree-item').forEach(li => processItem(li));
    }

    tree?.addEventListener('click', (e) => {
      const target = e.target;
      if (!(target instanceof HTMLElement)) return;

      const favBtn = target.closest('[data-tree-fav]');
      if (favBtn instanceof HTMLButtonElement) {
        toggleFav(favBtn);
        e.stopPropagation();
        return;
      }

      const toggleBtn = target.closest('[data-tree-toggle]');
      if (toggleBtn instanceof HTMLButtonElement) {
        const li = toggleBtn.closest('.tree-group');
        toggleGroup(li);
        // ç‚¹ä¸‰è§’ä¹Ÿè§†ä¸ºé€‰ä¸­è¯¥æ–‡ä»¶å¤¹ï¼Œå¹¶åˆ·æ–°å³ä¾§ï¼ˆéšæœºè€ŒåŠ¨ï¼‰
        const row = li?.querySelector(':scope > .tree-row');
        if (row) setSelectedRow(row);
        if (li) renderVideosForGroup(li);
        e.stopPropagation();
        return;
      }

      const row = target.closest('[data-tree-row]');
      if (row instanceof HTMLElement) {
        setSelectedRow(row);
        const li = row.closest('.tree-item');
        if (li?.classList.contains('tree-group')) {
          renderVideosForGroup(li);
        } else if (li?.classList.contains('tree-leaf')) {
          renderVideosForLeaf(li);
        }
      }
    });

    // æ”¯æŒæŒ‰ Enter / ç‚¹å‡»æŒ‰é’® / è¾“å…¥å®æ—¶è¿‡æ»¤
    treeSearchBtn?.addEventListener('click', () => filterTree(treeSearchInput?.value || ''));
    treeSearchInput?.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') filterTree(treeSearchInput?.value || '');
      if (e.key === 'Escape') { treeSearchInput.value = ''; filterTree(''); }
    });
    treeSearchInput?.addEventListener('input', () => filterTree(treeSearchInput.value || ''));

    // ç»‘å®šæŒ‰é’®
    btnLogin?.addEventListener('click', async () => {
      try {
        await doLogin();
      } catch (e) {
        setStatus(`çŠ¶æ€ï¼šç™»å½•å¤±è´¥ - ${(e && e.message) ? e.message : String(e)}`);
      }
    });
    btnLoadChannels?.addEventListener('click', async () => {
      try {
        await loadChannels();
      } catch (e) {
        setStatus(`çŠ¶æ€ï¼šåŠ è½½é€šé“å¤±è´¥ - ${(e && e.message) ? e.message : String(e)}`);
      }
    });
    btnLogout?.addEventListener('click', () => {
      state.token = '';
      saveState();
      destroyPlayers();
      renderChannelTree([]);
      setStatus('çŠ¶æ€ï¼šå·²é€€å‡ºï¼ˆToken å·²æ¸…é™¤ï¼‰ã€‚');
    });

    btnTestPlay?.addEventListener('click', () => {
      testCurrentPlayUrl();
    });
    btnClearDiag?.addEventListener('click', () => {
      diag.lines = [];
      if (diagBox instanceof HTMLTextAreaElement) diagBox.value = '';
    });
    btnCopyDiag?.addEventListener('click', async () => {
      const text = diag.lines.join('\n');
      try {
        await navigator.clipboard.writeText(text);
        setStatus('çŠ¶æ€ï¼šè¯Šæ–­å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ã€‚');
      } catch {
        if (diagBox instanceof HTMLTextAreaElement) {
          diagBox.focus();
          diagBox.select();
          setStatus('çŠ¶æ€ï¼šè¯·æ‰‹åŠ¨ Ctrl+C å¤åˆ¶è¯Šæ–­ã€‚');
        }
      }
    });

    // åˆå§‹åŒ–ï¼šæ¢å¤æœ¬åœ°ä¿å­˜çš„ base/token/device
    loadState();
    // å¦‚æœç”¨æˆ·ç”¨æœ¬åœ°ä»£ç†æ‰“å¼€é¡µé¢ï¼Œé»˜è®¤æŠŠ upstreamUrl ä¿æŒä¸ºå¹³å°çœŸå®åœ°å€
    state.upstreamUrl = normalizeUpstreamUrl(state.upstreamUrl || 'http://13.238.254.66:18000');
    if (apiBaseInput) apiBaseInput.value = state.baseUrl;
    if (apiUserInput) apiUserInput.value = state.username;
    if (apiDeviceInput) apiDeviceInput.value = state.deviceId;
    setStatus(state.token ? `çŠ¶æ€ï¼šå·²æ£€æµ‹åˆ°æœ¬åœ° Tokenï¼ˆ${state.username || 'æœªçŸ¥ç”¨æˆ·'}ï¼‰ã€‚å¯ç›´æ¥â€œåŠ è½½é€šé“åˆ—è¡¨â€ã€‚` : 'çŠ¶æ€ï¼šæœªç™»å½•ã€‚');
    renderChannelTree([]);
    logDiag(`init: origin=${location.origin} href=${location.href}`);
    if (location.protocol === 'file:') {
      logDiag('è­¦å‘Šï¼šä½ æ­£åœ¨ç”¨ file:// æ‰“å¼€é¡µé¢ã€‚æµè§ˆå™¨é€šå¸¸ä¼šå› ä¸º CORS æ‹¦æˆªè€Œæ— æ³•æ‹‰å– HLS åˆ†ç‰‡/FLV æ•°æ®ï¼Œå¯¼è‡´é»‘å±ã€‚å»ºè®®ç”¨æœ¬é¡¹ç›®çš„æœ¬åœ°ä»£ç†æ–¹å¼æ‰“å¼€ï¼ˆè§ proxy_server.pyï¼‰ã€‚');
      setStatus('çŠ¶æ€ï¼šæ£€æµ‹åˆ° file:// æ‰“å¼€ã€‚å¤§æ¦‚ç‡ä¼šå›  CORS æ— æ³•æ’­æ”¾ã€‚å»ºè®®ç”¨æœ¬åœ°ä»£ç†å¯åŠ¨åç”¨ http://127.0.0.1:8000 æ‰“å¼€ã€‚');
    }
  </script>


</body></html>